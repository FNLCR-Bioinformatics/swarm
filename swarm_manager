#!/usr/local/bin/perl
# ===========================================================================
#
#                            PUBLIC DOMAIN NOTICE
#                     Center for Information Technology (CIT)
#                        National Institute of Health (NIH)
#
#  This software/database is a "United States Government Work" under the
#  terms of the United States Copyright Act.  It was written as part of
#  the author's official duties as a United States Government employee and
#  thus cannot be copyrighted.  This software is freely available
#  to the public for use.  The Center for Information Technology, The
#  National Institutes of Health, and the U.S. Government have not placed
#  any restriction on its use or reproduction.
#
#  Although all reasonable efforts have been taken to ensure the accuracy
#  and reliability of the software and data, CIT, NIH and the U.S.
#  Government do not and cannot warrant the performance or results that
#  may be obtained by using this software or data. CIT, NIH and the U.S.
#  Government disclaim all warranties, express or implied, including
#  warranties of performance, merchantability or fitness for any particular
#  purpose.
#
#  Please cite the author and the "NIH Biowulf Cluster" in any work or product
#  based on this material.
#
# ===========================================================================
use strict;
use HPCNIH::Staff::MySQL::Catalog;
use HPCNIH::Util::EmailTools;
use HPCNIH::Util::TimeTools;
use Storable;
use Fcntl ":flock";
use HPCNIH::Util::Tabulate;
use Data::Dumper;
use Date::Parse qw(str2time);
use HPCNIH::Util::PrintColors;
use HPCNIH::Util::Stopwatch;
use HPCNIH::Slurm::CurrentJobs;
use Time::Piece;
use POSIX qw(setsid strftime);
use DBI;
use FileHandle;
use File::Basename;
use FindBin qw($RealBin);
use Cwd 'abs_path';
use Sort::ArrayOfArrays;

my %OPT;
my %PAR;
$PAR{tempdir_index} = "/usr/local/logs/swarm_tempdir.idx";
$PAR{store} = "/usr/local/logs/swarm_manager.store";
$PAR{logfile_age} = 20; # read 20 days back in swarm logs
$PAR{NOW} = time();
$PAR{age_unit} = 86400;
$PAR{delete_age} = 6; # remove files when then they are 6 days old
tie $PAR{stopwatch},'HPCNIH::Util::Stopwatch';
$PAR{stopwatch} = 0; # reset the stopwatch

getOptions();

eval {
# Catch signals
  local $SIG{ALRM} = sub { die " TIMEOUT: $OPT{timeout} seconds elapsed" };
  local $SIG{INT} = sub { die " INT: don't interrupt me!" };
  local $SIG{KILL} = sub { die " KILL: arrggg!" };

# Set the alarm to go off -- do nothing if $OPT{timeout} is undefined
  alarm $OPT{timeout};

#--------------------------------------------------------------------------------------------------
# Stuff that needs a timeout goes here
#--------------------------------------------------------------------------------------------------

# open connection to mysql
  $PAR{dbh} = DBI->connect("DBI:mysql:;mysql_read_default_group=dashboard;mysql_read_default_file=/usr/local/etc/my.cnf;mysql_connect_timeout=10",undef,undef,{RaiseError=>0,PrintError=>0,AutoCommit=>0}) or try_connecting_again();

# manipulate the store file
  add_to_message((sprintf "startup = %.2f",$PAR{stopwatch}),1) if $OPT{timing};
  if ($OPT{purge}) {
    purge_and_exit();
  }

  if ($OPT{dump}) {
    dump_and_exit();
  }
# Find the current status of swarms
  else {
    print_swarm_usage() if (($OPT{delete}) && ($OPT{verbose} > 0));
    read_from_store();
    parse_index_file();
    parse_swarm_logs();
    parse_jobs_table();

# Print summary
    if ($OPT{verbose} > 2) {
      print_data_level_3();
    }
    elsif ($OPT{verbose} == 2) {
      print_data_level_2();
    }
    elsif ($OPT{verbose} == 1) {
      print_data_level_1();
    }

# Delete the directories and files
    delete_directories_and_files() if ($OPT{delete});

# Make the data permanent
    write_to_store() if ($OPT{update} && !$OPT{debug});
    print_swarm_usage() if (($OPT{delete}) && ($OPT{verbose} > 0));
  }

# Send a report if you must
  if ($OPT{emailTo}) {
    sendEmail(subject=>$0,message=>$PAR{message},emailTo=>$OPT{emailTo},Bcc=>$OPT{Bcc},debug=>$OPT{debug},provenance=>1);
  }
  else {
    print $PAR{message};
  }

#--------------------------------------------------------------------------------------------------
# Done
#--------------------------------------------------------------------------------------------------

  alarm 0;
  1;  # default return value from eval
};

# Take action if either an error is given or the timeout was reached
if ( $@ ) {
  print STDERR $@;
  if ($OPT{emailTo}) {
    sendEmail(subject=>"ERROR: $0",message=>$@,emailTo=>$OPT{emailTo},Bcc=>$OPT{Bcc},debug=>$OPT{debug},provenance=>1);
  }
  exit 1;
}

#==================================================================================================
sub getOptions
{ 
  use Getopt::Long qw(:config no_ignore_case);
  Getopt::Long::Configure("bundling"); # allows option bundling
  GetOptions(
    'help' => \$OPT{help},
    'h' => \$OPT{help},
    'debug' => \$OPT{debug},
    'verbose=i' => \$OPT{verbose},
    'd' => \$OPT{debug},
    'dump' => \$OPT{dump},
    'delete' => \$OPT{delete},
    'report' => \$OPT{report},
    'purge' => \$OPT{purge},
    'update' => \$OPT{update},
    'delete_age=i' => \$OPT{delete_age}, 
    'tab' => \$OPT{tab},
    'timing' => \$OPT{timing},
    'v=i' => \$OPT{verbose},
    'timeout=i' => \$OPT{timeout}, 
    'email=s'=> \$OPT{emailTo},
    'bcc=s' => \$OPT{Bcc}, 
    'hours' => \$OPT{hours}, 
    'minutes' => \$OPT{minutes}, 
    'u=s' => \$OPT{user}, 
    'user=s' => \$OPT{user}, 
    'j=i' => \$OPT{jobid}, 
    'jobid=i' => \$OPT{jobid}, 
    's=s' => \$OPT{state}, 
    'state=s' => \$OPT{state}, 
    't=s' => \$OPT{tempdir}, 
    'tempdir=s' => \$OPT{tempdir}, 
  ) || printOptions();

  printOptions() if $OPT{help};

  if ($OPT{dump}) {
    $OPT{report} = 1;
    undef $OPT{update};
    undef $OPT{delete};
    $OPT{verbose} = 2 unless (defined $OPT{verbose});
  }  

  if ($OPT{purge}) {
    $OPT{report} = 1;
    undef $OPT{update};
    undef $OPT{delete};
  }

  unless ($OPT{update} || $OPT{report} || $OPT{delete}) {
    dieWithError("You must choose --dump, --report, --update, --delete, or --purge");
  }

  add_to_message("Running in debug mode") if $OPT{debug};
  $OPT{verbose} = 2 if ((defined $OPT{debug}) && (not defined $OPT{verbose}));
  $OPT{verbose} = 2 if ((defined $OPT{dump}) && (not defined $OPT{verbose}));
  $OPT{verbose} = 1 unless (defined $OPT{verbose});
  $OPT{verbose} = 0 if ((defined $OPT{verbose}) && ($OPT{verbose} < 0));

  if ($OPT{state} && (
    ($OPT{state} ne 'CREATED') && ($OPT{state} ne 'PENDING') && ($OPT{state} ne 'RUNNING')
    && ($OPT{state} ne 'FINISHED') && ($OPT{state} ne 'UNKNOWN') && ($OPT{state} ne 'MIXED'))) {
    dieWithError("--state must be CREATED, PENDING, RUNNING, FINISHED, UNKNOWN or MIXED");
  }

  $OPT{update} = 1 if $OPT{delete};

  if ($OPT{update} && $>) {
    dieWithError("you must be root!");
  }

  if ($OPT{delete_age}) {
    if ($OPT{delete_age} > $PAR{delete_age}) {
      $PAR{delete_age} = $OPT{delete_age};
      add_to_message("Using delete_age = $PAR{delete_age}") if $OPT{verbose} > 1;
    }
  }
}
#==================================================================================================
sub printOptions
{
  my $msg = shift;
  warn "\n$msg\n" if $msg;

  print STDERR <<EOF;

Usage: $0 [ options ]

Description:

  Evaluate the states of swarms as recorded in the index file and the
  dashboard jobs table.  The information is displayed in increasing detail,
  depending on the value of --verbose.

  If --dump is given, then the contents of the store file will be dumped out
  in a structured format.

  If --report is given, the contents of the store file will be merged with the
  parsed contents of the index and log files, and the total sum will be 
  reported.  The store file will not be modified.

  If --update is given, the same procedure as --report will be run, but further
  the index file will be rotated, and the updated contents will be stored in
  the store file.

  If --delete is given, then the temporary directories and symlink 
  associated with the swarm will be deleted, if it exists, and if the
  swarm finished more than $PAR{delete_age} days ago.  --update is
  also set, the index file is rotated, and the store file is appended.

  If --purge is given, then the store file is pruned of swarms that have been
  deleted.  Unfortunately, if the index and log files are parsed too far in
  the past, swarms that have been pruned will be redisplayed with --report
  and reinserted into the store file with --update.

  index file:

    $PAR{tempdir_index}

  store file:

    $PAR{store}

Options:

  --dump               dump the data in a hierarchical fashion

  --report             print out current status, don't modify anything

  --update             wipe out index file, print to store file.  Must be
                       root.

  --delete             actually attempt to delete the swarm tempdir and 
                       associated files.  --delete implies --update.  Must
                       be root.

  --purge              remove DELETED swarms from the store file

  -u/--user            filter for those swarms owned by this user
  -j/--jobid           filter for the swarm with this jobid
  -s/--state           filter for swarms with this state (choose from CREATED,
                       PENDING, RUNNING, FINISHED, MIXED, UNKNOWN)

  --hours              show age in hours, rather than days
  --minutes            show age in minutes, rather than days

  --email <emails>     comma-delimited list of email addresses to receive
                       reports.  If --debug is given, the emails will NOT be
                       sent.
  --bcc <emails>       same as --email, except as bcc

  --timeout <seconds>  give a timeout for the script

  -h, --help           print options list
  -d, --debug          run in debug mode 
  -v, --verbose        increase verbosity level (0,1,2,3)
  --timing             print timing information

Last modification date: 07 Jun 2017 (David Hoover)

EOF
  
  exit;
}
#=================================================================================================
sub parse_index_file
{
  $PAR{stopwatch} = 0; # reset the stopwatch
# To keep things simple, the index files will be shifted
  return unless (-f $PAR{tempdir_index});
#  system("/bin/cp $PAR{tempdir_index} $PAR{tempdir_index}.work");

# Parse tempdir_index file
  open FILE1, "<$PAR{tempdir_index}.work";
  LINE: while (<FILE1>) {
    chomp(my $line = $_);
    while ($line=~/(\d{10}),([^,]+),(\w{10}),(\d+),([12])/g) { # Hiccups in the write performance of /spin1
      my ($time,$user,$t,$nsubjobs,$p) = ($1,$2,$3,$4,$5);
      next LINE if ($PAR{data}{$t}{state}); # don't bother if already known
      $PAR{data}{$t}{create_time} = $time;
      $PAR{data}{$t}{user} = $user;
      $PAR{data}{$t}{tempname} = $t;
      $PAR{data}{$t}{nsubjobs} = $nsubjobs;
      $PAR{data}{$t}{p} = $p;
      $PAR{data}{$t}{state} = "CREATED";
      foreach my $i (0 .. $PAR{data}{$t}{nsubjobs}-1) {
        ${$PAR{data}{$t}{states}}[$i] = 'CREATED'; 
      }
    }
  }
  close FILE1;
  add_to_message((sprintf "parse_index_file = %.2f",$PAR{stopwatch}),1) if $OPT{timing};
}
#=================================================================================================#
#sub _most_recent_create_time
#{
#  my $oldest = 0;
#  foreach my $t (keys %{$PAR{data}}) {
#    if ((defined $PAR{data}{$t}{create_time}) && ($PAR{data}{$t}{create_time} > $oldest)) {
#      $oldest = $PAR{data}{$t}{create_time}; 
#    }
#  }
#  return $oldest; 
#}
#=================================================================================================#
sub parse_swarm_logs
{
  $PAR{stopwatch} = 0; # reset the stopwatch
# Barf barf barf -- this is insurance
  my @files;
  chomp(my $x = `/bin/find /usr/local/logs/swarm_log_archives -type f -mtime -$PAR{logfile_age}`);
  @files = split /\n/,$x;
  push @files,"/usr/local/logs/swarm.log";

# Find the most recent create_time, if known, to avoid stupidity
#  my $cutoff = strftime("%Y%m%d", (localtime(_most_recent_create_time()))[0 .. 5]); 

  FILE: foreach my $f (@files) {
#    if ($f=~/-(\d{8})$/) { next FILE if ($cutoff > $1); } # Skip logfiles already parsed
    if (open FILE, "<$f") {
      LINE: while (<FILE>) {
        my $line = $_;
        my $t = $1              if ($line=~/ tempname=([^;]+); /);
        my $time = str2time($1) if ($line=~/^date=([^;]+); /);
        my $user = $1           if ($line=~/ user=([^;]+); /);
        my $jobid = $1          if ($line=~/ jobid=([^;]+); /);
        my $nsubjobs = $1       if ($line=~/ njobs=([^;]+); /);
        my $p = 1;
        $p = 2 if ($line=~/; command=.+-p 2 /);
        if ($t) {
          next LINE if ($PAR{data}{$t}{jobid}); # don't bother if already known
          $PAR{data}{$t}{create_time} = $time unless $PAR{data}{$t}{create_time};
          $PAR{data}{$t}{user} = $user;
          $PAR{data}{$t}{tempname} = $t;
          $PAR{data}{$t}{nsubjobs} = $nsubjobs;
          $PAR{data}{$t}{p} = $p if $p;
          $PAR{data}{$t}{submit_time} = $time;
          $PAR{data}{$t}{jobid} = $jobid;
          $PAR{jobid2tempname}{$jobid}=$t;
          $PAR{data}{$t}{state} = "SUBMITTED";
          foreach my $i (0 .. $PAR{data}{$t}{nsubjobs}-1) {
            ${$PAR{data}{$t}{states}}[$i] = 'SUBMITTED';
          }
        }
      }
      close FILE;
    }
  }
  add_to_message((sprintf "parse_swarm_logs = %.2f",$PAR{stopwatch}),1) if $OPT{timing};
}
#=================================================================================================#
sub read_from_store
{
  open(FH, ">$PAR{store}.lck")        or dieWithError("can't create lock $PAR{store}.lck: $!");
  flock(FH, 2)                        or dieWithError( "can't flock $PAR{store}.lck: $!");
  my $hr = retrieve($PAR{store})      if (-f $PAR{store});
  close(FH)                           or dieWithError("can't remove lock $PAR{store}.lck: $!");
  unlink "$PAR{store}.lck";
  if (defined $hr) {
    ROW: foreach my $t (sort keys %{$hr}) { 
      next unless $t;
      $PAR{data}{$t} = $hr->{$t};
      $PAR{jobid2tempname}{$PAR{data}{$t}{jobid}}=$t if (defined $PAR{data}{$t}{jobid});
    }
  }
}
#==================================================================================================
sub write_to_store
{
  open(FH, ">$PAR{store}.lck")        or dieWithError("can't create lock $PAR{store}.lck: $!");
  flock(FH, 2)                        or dieWithError("can't flock $PAR{store}.lck: $!");
  unlink $PAR{store} if (-f $PAR{store});
  store($PAR{data},$PAR{store});
  close(FH)                           or dieWithError("can't remove lock $PAR{store}.lck: $!");
  unlink "$PAR{store}.lck";
  chmod 0644,$PAR{store};
}
#==================================================================================================
sub parse_jobs_table
{
# Don't be stupid
  return if ($OPT{tempdir} && (_finished($OPT{tempdir})));

# Do some filtering if needed
  my @f;
  push @f,"`user`='$OPT{user}'" if $OPT{user};
  push @f,"(`jobidarray` LIKE '$OPT{jobid}_%' OR `jobid` = $OPT{jobid})" if $OPT{jobid};
  my $filter;
  if (@f) {
    $filter = join " AND ",@f;
    $filter = "WHERE ".$filter;
  }

# Pull out everything from jobs table, and determine the tempdir name
  $PAR{stopwatch} = 0; # reset the stopwatch
  my $sql = "SELECT * FROM dashboard.jobs $filter";
  my $a = $PAR{dbh}->selectall_hashref($sql,["jobid"]);
  JOB: foreach my $jobid (sort keys %{$a}) { # sorting essential to populate states correctly
    my $t;
# Typically a swarm has a value in the jobidarray field
    if (defined $a->{$jobid}->{jobidarray}) {
      my $j = $1 if ($a->{$jobid}->{jobidarray}=~/^(\d+)_/);
      if ((defined $j) && (defined $PAR{jobid2tempname}{$j})) {
        $t = $PAR{jobid2tempname}{$j};
      }
    }
# The jobidarray value is not set if the swarm is cancelled before starting, I think
    elsif (defined $PAR{jobid2tempname}{$jobid}) {
      $t = $PAR{jobid2tempname}{$jobid};
    }

    next JOB unless $t; # Don't be stupid
    next JOB if (_finished($t) || $PAR{data}{$t}{deleted});

# Fill in the swarm arrays
    _fill_swarm_arrays($t,$a->{$jobid});

  } # end jobs table
  add_to_message((sprintf "walk_jobs_table = %.2f",$PAR{stopwatch}),1) if $OPT{timing};

# What about unfinished swarms that were not found in the jobs database?
  $PAR{stopwatch} = 0; # reset the stopwatch
  SWARM2: foreach my $t (keys %{$PAR{data}}) {
    next SWARM2 if (_finished($t) || $PAR{data}{$t}{deleted});
    next SWARM2 unless (defined $PAR{data}{$t}{jobid});
    foreach my $i (0 .. $PAR{data}{$t}{nsubjobs}-1) {
# The subjob was seen in the jobs table at somepoint in time
      if (defined ${$PAR{data}{$t}{subjobid}}[$i]) {
        if (not defined $a->{${$PAR{data}{$t}{subjobid}}[$i]}->{jobid}) {
          ${$PAR{data}{$t}{states}}[$i] = 'EXPIRED';
        }
      }
# The subjob was never seen in the jobs table
      else {
        ${$PAR{data}{$t}{states}}[$i] = 'UNKNOWN';
      }
    }
  }
  add_to_message((sprintf "rewalk_jobs_data = %.2f",$PAR{stopwatch}),1) if $OPT{timing};

  _simplify_states_and_end_times();
}
#=================================================================================================
sub _fill_swarm_arrays
# Add the jobid, state, and end_time for the subjobs represented by this line
{
  my ($t,$x) = @_;

# NOTE: This does not cover all possibilities for job arrays under Slurm.  However, swarm will
# only give a single subjob, or a range of subjobs, starting from 0.  --maxrunning will add a
# % sign followed by max simultaneous jobs.
  if ($x->{jobidarray} =~ /^\d+_(\d+)$/) {
    my $i = $1;
    _update_swarm_array($t,$x,$i);
  }
  elsif ($x->{jobidarray} =~ /^\d+_\[(\d+)\]$/) {
    my $i = $1;
    _update_swarm_array($t,$x,$i);
  }
  elsif ($x->{jobidarray} =~ /^\d+_\[(\d+)-(\d+)/) {
    foreach my $i ($1 .. $2) {
      _update_swarm_array($t,$x,$i);
    }
  }
# Likely the swarm was cancelled before it got out of pending
  elsif ((not defined $x->{jobidarray}) && (defined $PAR{data}{$t}{jobid}) && ($x->{jobid} == $PAR{data}{$t}{jobid})) {
    foreach my $i (0 .. $PAR{data}{$t}{nsubjobs}-1) {
      _update_swarm_array($t,$x,$i);
    }
  }
}
#=================================================================================================
sub _update_swarm_array
{
  my ($t,$x,$i) = @_;
  ${$PAR{data}{$t}{subjobid}}[$i] = $x->{jobid};
  if (defined $x->{state}) {
    ${$PAR{data}{$t}{states}}[$i] = $x->{state};
    if (defined $x->{end_time}) {
      ${$PAR{data}{$t}{end_times}}[$i] = $x->{end_time};
    } else {
      ${$PAR{data}{$t}{end_times}}[$i] = 0;
    }
  }
}
#=================================================================================================
sub _simplify_states_and_end_times
{
  $PAR{stopwatch} = 0; # reset the stopwatch
# Simplify the states into a single state
  SWARM: foreach my $t (keys %{$PAR{data}}) {

# Don't bother if the swarm is finished
    next SWARM if (_finished($t) || $PAR{data}{$t}{deleted}); 

# Find max end_time, if possible
    if ($PAR{data}{$t}{end_times}) {
      E: foreach my $e (@{$PAR{data}{$t}{end_times}}) {
        next E unless ($e > 0);
        if (not defined $PAR{data}{$t}{max_end_time}) {
          $PAR{data}{$t}{max_end_time} = $e;
        }
        elsif ($PAR{data}{$t}{max_end_time} < $e) {
          $PAR{data}{$t}{max_end_time} = $e;
        }
      }
    }
    my %tmp; $tmp{C}=0; $tmp{S}=0; $tmp{P}=0; $tmp{R}=0; $tmp{F}=0; $tmp{E}=0; $tmp{U}=0; $tmp{done}=0;
    if ($PAR{data}{$t}{states}) {
      foreach my $s (@{$PAR{data}{$t}{states}}) {
        if ($s eq 'CREATED') { $tmp{C}++; }
        elsif ($s eq 'SUBMITTED') { $tmp{S}++; }
        elsif ($s eq 'PENDING') { $tmp{P}++; }
        elsif ($s eq 'RUNNING') { $tmp{R}++; }
        elsif ($s eq 'EXPIRED') { $tmp{E}++; $tmp{done}++; }
        elsif ($s eq 'UNKNOWN') { $tmp{U}++; $tmp{done}++; }
        else { $tmp{F}++; $tmp{done}++; }
      }

# The state reported will either be C, S, P, R, F, or M

# The state is uniform:
      if    ($PAR{data}{$t}{nsubjobs} == $tmp{C}) { _update_value($t,'state','CREATED'); }
      elsif ($PAR{data}{$t}{nsubjobs} == $tmp{S}) { _update_value($t,'state','SUBMITTED'); }
      elsif ($PAR{data}{$t}{nsubjobs} == $tmp{P}) { _update_value($t,'state','PENDING'); }
      elsif ($PAR{data}{$t}{nsubjobs} == $tmp{R}) { _update_value($t,'state','RUNNING'); }
      elsif ($PAR{data}{$t}{nsubjobs} == $tmp{E}) { _update_value($t,'state','EXPIRED'); }
      elsif ($PAR{data}{$t}{nsubjobs} == $tmp{U}) { _update_value($t,'state','UNKNOWN'); }
      elsif (($PAR{data}{$t}{nsubjobs} == $tmp{F}) && (defined $PAR{data}{$t}{max_end_time}) && ($PAR{data}{$t}{max_end_time} =~ /^\d+$/)) {
        _update_value($t,'state','FINISHED');
        _update_value($t,'end_time',$PAR{data}{$t}{max_end_time});
      }
# The state is mixed
      else { 
# The substates are uniformly done states 
        if ($PAR{data}{$t}{nsubjobs} == $tmp{done}) {
          _update_value($t,'state','FINISHED');
# At least one of the subjobs has finished with an end_time
          if ((defined $PAR{data}{$t}{max_end_time}) && ($PAR{data}{$t}{max_end_time} =~ /^\d+$/)) {
            _update_value($t,'end_time',$PAR{data}{$t}{max_end_time});
          }
# The whole swarm is expired or unknown
          else {
            _update_value($t,'end_time',$PAR{data}{$t}{create_time});
          }
        } 
# The substates are a mixture of done and undone states
        else {
          _update_value($t,'state','MIXED'); 
        }
      }
    }
  }
  add_to_message((sprintf "simpify_states = %.2f",$PAR{stopwatch}),1) if $OPT{timing};
}
#=================================================================================================
sub _update_value
{
  my ($t,$key,$value) = @_;
  return unless ((defined $t) && (defined $key) && (defined $value));
  $PAR{data}{$t}{$key} = $value;
}
#=================================================================================================
sub _find_action
{
  my $t = shift;
  if (_deletable($t)) { return 'DELETE'; }
  elsif ($PAR{data}{$t}{deleted}) { return 'IGNORE'; }
  else { return 'KEEP'; }
}
#=================================================================================================
sub print_data_level_2
{
  $PAR{stopwatch} = 0; # reset the stopwatch
  my $x;
  foreach my $t (keys %{$PAR{data}}) {
    next if ($OPT{user} && ($PAR{data}{$t}{user} ne $OPT{user}));
    next if ($OPT{jobid} && ($PAR{data}{$t}{jobid} ne $OPT{jobid}));
    next if ($OPT{state} && ($PAR{data}{$t}{state} ne $OPT{state}));
    next if ($OPT{tempdir} && ($t ne $OPT{tempdir}));
    #next if ($PAR{data}{$t}{state} eq 'DELETED');
    next if ($OPT{delete} && (!_deletable($t)));

# Push into array of hashrefs if needed
    push @{$x}, {
      tempname => $PAR{data}{$t}{tempname},
      user => $PAR{data}{$t}{user},
      state => $PAR{data}{$t}{state},
      age => _find_age($t),
      action => _find_action($t),
      jobid => $PAR{data}{$t}{jobid},
      nsubjobs => $PAR{data}{$t}{nsubjobs},
      p => $PAR{data}{$t}{p},
    };
  }

  if ($x) {
    my $m1 =  createMatrix(array=>$x,horizontal=>1,fields=>['tempname','user','state','age','action','jobid','nsubjobs','p']);
# Sort the data
    my $sort = Sort::ArrayOfArrays->new({
      results => $m1,
      header_row => 1, # first array is the header row
      sort_column => '1,5,3,0', # sort user, then jobid, then age, then tempname
      sort_code => ['aa','aa','aa','nd','aa','na','na','na'], 
    });
    my $results = $sort->sort_it;
  
    if ($OPT{tab}) {
      add_to_message(printMatrix($results));
    }
    else {
      add_to_message(printMatrixNeatly(matrix=>$results,horizontal_separator=>1,horizontal_character=>'='));
    }
  }
  add_to_message((sprintf "print_data_level_2 = %.2f",$PAR{stopwatch}),1) if $OPT{timing};
}
#=================================================================================================
sub _find_age
{
  my $t = shift;
  my $age;
  my $age_unit = $PAR{age_unit};
  $age_unit = 3600 if $OPT{hours};
  $age_unit = 60 if $OPT{minutes};

  if ($PAR{data}{$t}{max_end_time}) {
    $age = int(($PAR{NOW}-$PAR{data}{$t}{max_end_time})/$age_unit);
  } elsif ($PAR{data}{$t}{submit_time}) {
    $age = int(($PAR{NOW}-$PAR{data}{$t}{submit_time})/$age_unit);
  } elsif ($PAR{data}{$t}{create_time}) {
    $age = int(($PAR{NOW}-$PAR{data}{$t}{create_time})/$age_unit);
  } else {
    $age = -1;
  }
  return $age;
}
#=================================================================================================
sub print_data_level_1
{
  $PAR{stopwatch} = 0; # reset the stopwatch
  my $x;
  my $u;
  foreach my $t (keys %{$PAR{data}}) {
    next if ($OPT{user} && ($PAR{data}{$t}{user} ne $OPT{user}));
    next if ($OPT{jobid} && ($PAR{data}{$t}{jobid} ne $OPT{jobid}));
    next if ($OPT{state} && ($PAR{data}{$t}{state} ne $OPT{state}));
    next if ($OPT{tempdir} && ($t ne $OPT{tempdir}));
    next if ($PAR{data}{$t}{state} eq 'DELETED');
    $x->{finished}++ if _finished($t);
    $x->{created}++ if ($PAR{data}{$t}{state} eq 'CREATED');
    $x->{submitted}++ if ($PAR{data}{$t}{state} eq 'SUBMITTED');
    $x->{expired}++ if ($PAR{data}{$t}{state} eq 'EXPIRED');
    $x->{pending}++ if ($PAR{data}{$t}{state} eq 'PENDING');
    $x->{running}++ if ($PAR{data}{$t}{state} eq 'RUNNING');
    $x->{mixed}++ if ($PAR{data}{$t}{state} eq 'MIXED');
    $x->{files} += ($PAR{data}{$t}{nsubjobs}*$PAR{data}{$t}{p}); # the cmd scripts
    if ($PAR{data}{$t}{state} eq 'UNKNOWN') {
      $x->{files} += 2; # batch script and directory
      $x->{unknown}++;
    }
    else {
      $x->{files} += 3; # batch script, directory, and symlink
    }
    if (!$u->{$PAR{data}{$t}{user}}) {
      $x->{files} += 1; # parent directory
    }
    if (_deletable($t)) {
      $x->{delete}++;
    }
    else {
      $x->{keep}++;
    }
    $u->{$PAR{data}{$t}{user}}++;
  }
  add_to_message(sprintf ("files=%d\ncreated=%d,submitted=%d,pending=%d,running=%d,finished=%d,mixed=%d,expired=%d,unknown=%d\ndelete=%d,keep=%d\n",
    $x->{files}, $x->{created}, $x->{submitted}, 
    $x->{pending}, $x->{running}, $x->{finished}, $x->{mixed}, $x->{expired}, $x->{unknown},
    $x->{delete}, $x->{keep},
  ));
  add_to_message((sprintf "print_data_level_1 = %.2f",$PAR{stopwatch}),1) if $OPT{timing};
}
#=================================================================================================
sub delete_directories_and_files
{
  $PAR{stopwatch} = 0; # reset the stopwatch
# Choose our victims
  my @victims;
  foreach my $t (keys %{$PAR{data}}) {
    next if ($OPT{user} && ((not defined $PAR{data}{$t}{user}) || ($PAR{data}{$t}{user} ne $OPT{user})));
    next if ($OPT{jobid} && ((not defined $PAR{data}{$t}{jobid}) || ($PAR{data}{$t}{jobid} ne $OPT{jobid})));
    next if ($OPT{state} && ((not defined $PAR{data}{$t}{state}) || ($PAR{data}{$t}{state} ne $OPT{state})));
    next if ($OPT{tempdir} && ($t ne $OPT{tempdir}));
    push @victims, $t if (_deletable($t));
  }
  add_to_message((sprintf "choosing victims = %.2f",$PAR{stopwatch}),1) if $OPT{timing};

  $PAR{stopwatch} = 0; # reset the stopwatch
# Delete the victims in clumps of 20
  my $list;
  foreach my $i (0..$#victims) {
    my $t = $victims[$i];
    $list .= " /spin1/swarm/".$PAR{data}{$t}{user}."/".$t if ($t);
    my $print_list = "rm -rf /spin1/swarm/".$PAR{data}{$t}{user}."/".$t;
    $list .= " /spin1/swarm/".$PAR{data}{$t}{user}."/".$PAR{data}{$t}{jobid} if ($PAR{data}{$t}{jobid});
    $print_list .= " /spin1/swarm/".$PAR{data}{$t}{user}."/".$PAR{data}{$t}{jobid} if ($PAR{data}{$t}{jobid});
    add_to_message($print_list) if (defined $OPT{verbose} && $OPT{verbose} > 1);
    if (!$OPT{debug}) {
      $PAR{data}{$t}{deleted} = 1;
      $PAR{data}{$t}{state} = "DELETED";
    }
    if ((!($i%20)) || ($i == $#victims)) {
      my $cmd = "rm -rf $list";
      undef $list;
      if (!$OPT{debug}) {
        system($cmd);
      }
    }
  }
  if ($OPT{verbose} > 1) {
    if (!@victims) {
      add_to_message("Nothing to delete");
    }
  }
  add_to_message((sprintf "delete_directories_and_files = %.2f",$PAR{stopwatch}),1) if $OPT{timing};
}
#=================================================================================================
sub _deletable
{
  my $t = shift;
  return if $PAR{data}{$t}{deleted};
  my $age;
  if ($PAR{data}{$t}{max_end_time}) {
    $age = int(($PAR{NOW}-$PAR{data}{$t}{max_end_time})/$PAR{age_unit});
  } elsif ($PAR{data}{$t}{submit_time}) {
    $age = int(($PAR{NOW}-$PAR{data}{$t}{submit_time})/$PAR{age_unit});
  } elsif ($PAR{data}{$t}{create_time}) {
    $age = int(($PAR{NOW}-$PAR{data}{$t}{create_time})/$PAR{age_unit});
  } else {
    $age = -1;
  }
  if (($age >= $PAR{delete_age}) && (((defined $PAR{data}{$t}{jobid}) && _finished($t)) || ($PAR{data}{$t}{state} eq 'CREATED') || ($PAR{data}{$t}{state} eq 'UNKNOWN'))) {
    return 1;
  }
}
#=================================================================================================
sub _finished
{
  my $t = shift;
  return 1 if ((defined $PAR{data}{$t}{state}) && ($PAR{data}{$t}{state} eq 'FINISHED') && (defined $PAR{data}{$t}{max_end_time})); 
}
#=================================================================================================
sub dump_and_exit
{
  read_from_store();
  my $x;
  foreach my $t (keys %{$PAR{data}}) {
    next if ($OPT{user} && ($PAR{data}{$t}{user} ne $OPT{user}));
    next if ($OPT{jobid} && ($PAR{data}{$t}{jobid} ne $OPT{jobid}));
    next if ($OPT{state} && ($PAR{data}{$t}{state} ne $OPT{state}));
    next if ($OPT{tempdir} && ($t ne $OPT{tempdir}));
    $PAR{data}{$t}{age} = _find_age($t);
    $PAR{data}{$t}{action} = _find_action($t);
    $x->{$t} = $PAR{data}{$t};
  }
  $OPT{verbose} = 1 if ($OPT{verbose} == 0);
  $Data::Dumper::Maxdepth=$OPT{verbose};
  add_to_message(Dumper($x));
}
#=================================================================================================
sub print_data_level_3
{
  $PAR{stopwatch} = 0; # reset the stopwatch
  my @printArray;
  foreach my $t (keys %{$PAR{data}}) {
    next if ($OPT{user} && ($PAR{data}{$t}{user} ne $OPT{user}));
    next if ($OPT{jobid} && ($PAR{data}{$t}{jobid} ne $OPT{jobid}));
    next if ($OPT{state} && ($PAR{data}{$t}{state} ne $OPT{state}));
    next if ($OPT{tempdir} && ($t ne $OPT{tempdir}));
    next if ($OPT{delete} && (!_deletable($t)));

# If the swarm was never submitted, only list the global values
    if (!$PAR{data}{$t}{submit_time}) {
      _add_created_swarm(\@printArray,$t);
# If the swarm was submitted, list values for each subjob
    } else {
      foreach my $i (0 .. $PAR{data}{$t}{nsubjobs}-1) {
        if ($i == 0) {
          _add_first_subjob(\@printArray,$t,$i,(_determine_subjob_age($t,$i)));
        } else {
          _add_subjob(\@printArray,$t,$i,(_determine_subjob_age($t,$i)));
        }
      }
    }
  }
  my $m1 =  createMatrix(array=>\@printArray,horizontal=>1,fields=>['tempname','user','state','age','action','jobid','nsj','p','cmd','sjobid','sstate','sage']);
  if ($OPT{tab}) {
    add_to_message(printMatrix($m1));
  }
  else {
    add_to_message(printMatrixNeatly(matrix=>$m1,horizontal_separator=>1,horizontal_character=>'='));
  }
  add_to_message((sprintf "print_data_level_3 = %.2f",$PAR{stopwatch}),1) if $OPT{timing};
}
#=================================================================================================
sub _determine_subjob_age
{
  my ($t,$i) = @_;
  my $s;
  if ((${$PAR{data}{$t}{states}}[$i] eq 'SUBMITTED') || (${$PAR{data}{$t}{states}}[$i] eq 'PENDING') || (${$PAR{data}{$t}{states}}[$i] eq 'RUNNING')) {
    $s = $PAR{NOW} - $PAR{data}{$t}{submit_time};
  } elsif (defined ${$PAR{data}{$t}{end_times}}[$i]) {
    $s = $PAR{NOW} - ${$PAR{data}{$t}{end_times}}[$i];
  } else {
    $s = $PAR{NOW} - $PAR{data}{$t}{create_time};
  }

# Recalculate age if needed
  if ($OPT{hours}) {
    $s = int($s/3600);
  } elsif ($OPT{minutes}) {
    $s = int($s/60);
  } else {
    $s = int($s/86400);
  }
  return $s;
}
#=================================================================================================
sub dieWithError
{
  my $message = shift;
  die "ERROR: $message\n";
}
#=================================================================================================
sub _add_first_subjob
{
  my ($y,$t,$i,$sage) = @_;
  push @{$y}, {
    tempname => $PAR{data}{$t}{tempname},
    user => $PAR{data}{$t}{user},
    jobid => $PAR{data}{$t}{jobid},
    state => $PAR{data}{$t}{state},
    age => _find_age($t),
    action => _find_action($t),
    nsj => $PAR{data}{$t}{nsubjobs},
    p => $PAR{data}{$t}{p},
    cmd => $i,
    sjobid => ${$PAR{data}{$t}{subjobid}}[$i],
    sstate => ${$PAR{data}{$t}{states}}[$i],
    sage => $sage,
  };
}
#=================================================================================================
sub _add_subjob
{
  my ($y,$t,$i,$sage) = @_;
  push @{$y}, {
    tempname => "-",
    user => "-",
    jobid => "-",
    state => "-",
    age => "-",
    action => "-",
    nsj => "-",
    p => "-",
    cmd => $i,
    sjobid => ${$PAR{data}{$t}{subjobid}}[$i],
    sstate => ${$PAR{data}{$t}{states}}[$i],
    sage => $sage,
  };
}
#=================================================================================================
sub _add_created_swarm
{
  my ($y,$t) = @_;
  push @{$y}, {
    tempname => $PAR{data}{$t}{tempname},
    user => $PAR{data}{$t}{user},
    jobid => $PAR{data}{$t}{jobid},
    state => $PAR{data}{$t}{state},
    age => _find_age($t),
    action => _find_action($t),
    nsj => $PAR{data}{$t}{nsubjobs},
    p => $PAR{data}{$t}{p},
  };
}
#=================================================================================================
sub print_swarm_usage
{
  my $cat = HPCNIH::Staff::MySQL::Catalog->new(catalog=>"quota_spin1");
  my $x = $cat->get_current(entity=>"/spin1/swarm");
  my $y = $x->{'/spin1/swarm'};
  my $string = sprintf("/swarm usage: %6.2f GB (%4.1f%%), %7d files (%4.1f%%)",
      ( $y->{dusage}/1024/1024 ),
      ( ($y->{dusage}/$y->{dquota})*100 ),
      ( $y->{fusage} ),
      ( ($y->{fusage}/$y->{fquota})*100 ),
  );
  add_to_message($string);
}
#=================================================================================================
sub purge_and_exit
{
# Removed the DELETED jobs from the store file
  read_from_store();
  my %new;
  foreach my $t (keys %{$PAR{data}}) {
    if (!$PAR{data}{$t}{state} eq 'DELETED') {
      $new{$t} = $PAR{data}{$t};
    }
  }
  $PAR{data} = \%new;
  write_to_store() unless $OPT{debug};
  exit;
}
#=================================================================================================
sub add_to_message
{
  my $msg = shift;
  my $immediate = shift;
  if ($immediate) {
    print $msg."\n";
  }
  else {
    $PAR{message} .= $msg."\n";
  }
}
#=================================================================================================
